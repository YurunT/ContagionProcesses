from scipy.stats import poisson
import numpy as np
import math
from mpmath import polylog
from scipy.stats import pareto


supported_degree_distributions = {'Poisson', 
                                  'PL', # Powerlaw
                                  'PLC' # Powerlaw-with-exp-cutoff
                                 }

def get_pd(pkc, pks, alpha):
    '''
    Get the colored degree distribution from degree sequences for layer 1 and layer 2
    
    Input:
    pkc: degree sequence for layer 1 (community layer in viral spread context)
    pks: degree sequence for layer 2 (school layer in viral spread context)
    alpha: second layer particiation rate
    
    Output:
    pd: np 2-D array with size dim(pkc) x dim(pks)
    pd[i][j] represents prob of (kc=i, ks=j) for the 2-layer network
    '''
    pks *= alpha
    pks[0] += (1 - alpha)
    pd = pkc.reshape(-1, 1).dot(pks.reshape(1, -1)) # kmax x kmax, vertical dimension is pkb, horizontal dimension is pkr
    return pd


def get_Poisson_pk(md, kmax):
    '''
    Colored degree distribution where each layer is generated by Poisson degree distribution
    
    Input:
    md: mean degree of the considered network. pk follows Poisson(md)
    kmax: largest k we consider for pk_layer
    '''
    pk = poisson.pmf(np.arange(kmax + 1), md) # [p(kb=0), p(kb=1), ..., p(kb=kmax-1)]
    moment_1st = md
    moment_2nd = md + md ** 2
    return pk, moment_1st, moment_2nd


def get_powerlaw_with_expcutoff_pk(alpha, kappa, kmax):
    def _makePowerlawWithCutoff(k, alpha, kappa):
        '''Create a model function for a powerlaw distribution with exponential cutoff.
        This function credits to https://pyepydemic.readthedocs.io/en/latest/cookbook/population-powerlaw-cutoff.html
        :param alpha: the exponent of the distribution; alpha here is lambda_ in Cojoining Speeds up... 
        :param kappa: the degree cutoff; kappa here is the gamma in Cojoining Speeds up... 
        :returns: a model function'''
        C = polylog(alpha, math.exp(-1.0 / kappa))
        def p( k ):
            if k == 0: # Only change we made is pk(0) = 0
                return 0
            return float((pow((k + 0.0), -alpha) * math.exp(-(k + 0.0) / kappa)) / C)
        return p
    
    # pk generator with given alpha (exponent of powerlaw) and kappa (degree cutoff)
    # This is much faster than epydemic.gf 
    get_pk = _makePowerlawWithCutoff(0, alpha, kappa) 

    pks = []
    for k in range(kmax + 1):
        pks.append(get_pk(k))
    
#     # first moment
#     from epydemic.gf import gf_plc
#     gf_plc = gf_plc(alpha, kappa) # Generating function for PLC(alpha, kappa), this is fast to generate the first moment, but very slow to generate probability for weird reason 
#     G0prime = gf_plc.dx()
#     moment_1st = float(G0prime(1) )
        
#     # This is just the approximation of the second moment
#     # larger the kmax, more accurate the approximation
#     moment_2nd = 0
#     for i in range(10+1):
#         moment_2nd += gf_plc[i] * i * i
    return np.array(pks), 1.4257689408749183, np.nan # second moment calculation too slow, return nan
    

def get_powerlaw(b: float, kmax: int) -> np.ndarray:
    '''
    To get the same exponents for 
    powerlaw_with_expcutoff(lambda, gamma) and powerlaw(b) is
    to make sure lambda = b+1, b=lamda-1
    '''
    x = np.arange(kmax+1)
    pk_list = pareto.pdf(x, b)
    mean, var = pareto.stats(b, moments='mv')
    moment_1st = float(mean)
    moment_2nd = float(var) + mean ** 2
    return pk_list, moment_1st, moment_2nd

def get_pk(distr_name: str, paras: dict, kmax: int):
    '''
    This function will return the np array of [pk] (k=0...kmax) for a given degree distribution
    and the corresponding theoritical first and second moment
    '''
    assert (distr_name in supported_degree_distributions), f'Degree distribbution {distr_name} is not supported, \
    available ones are: {supported_degree_distributions}'
    
    if distr_name == 'Poisson':
        '''
        Poisson(lambda)
        '''
        assert 'lambda' in paras.keys(), 'Need to specify lambda for Poisson(lambda), \
        usually equals to the mean degree'
        pk_list, moment1st, moment2nd = get_Poisson_pk(paras['lambda'], kmax)
    
    if distr_name == 'PL':
        '''
        Powerlaw(b)
        '''
        assert 'b' in paras.keys(), 'Need to specify b for Powerlaw(b)'
        pk_list, moment1st, moment2nd = get_powerlaw(paras['b'], kmax)
    
    if distr_name == 'PLC':
        '''
        Powerlaw-with-exponential-cutoff(alpha, kappa)
        '''
        assert 'alpha' in paras.keys(), 'Need to specify alpha(exponent) of PLC'
        assert 'kappa' in paras.keys(), 'Need to specify kappa(cutoff) of PLC'
#         pk_list, moment1st, moment2nd = get_powerlaw_with_expcutoff_pk(paras['alpha'], paras['kappa'], kmax)
        pk_list = np.array( [0.00000000e+00, 7.88381141e-01, 1.26104850e-01, 4.14070407e-02,
       1.82514723e-02, 9.45351729e-03, 5.42264108e-03, 3.33744746e-03,
       2.16274403e-03, 1.45778799e-03, 1.01361072e-03, 7.22703290e-04,
       5.26088952e-04, 3.89694672e-04, 2.92976854e-04, 2.23098065e-04,
       1.71788682e-04, 1.33580404e-04, 1.04774198e-04, 8.28175077e-05,
       6.59176509e-05, 5.27957576e-05, 4.25266441e-05, 3.44325175e-05,
       2.80111419e-05, 2.28865035e-05, 1.87744253e-05, 1.54582798e-05,
       1.27716217e-05, 1.05856293e-05, 8.79992746e-06, 7.33581797e-06,
       6.13124100e-06, 5.13699372e-06, 4.31387090e-06, 3.63048693e-06,
       3.06160591e-06, 2.58685319e-06, 2.18971530e-06, 1.85675960e-06,
       1.57702206e-06, 1.34152465e-06, 1.14289314e-06, 9.75053092e-07,
       8.32987076e-07, 7.12539955e-07, 6.10262212e-07, 5.23283409e-07,
       4.49209641e-07, 3.86040184e-07, 3.32099525e-07, 2.85981788e-07,
       2.46505157e-07, 2.12674415e-07, 1.83650059e-07, 1.58722794e-07,
       1.37292404e-07, 1.18850220e-07, 1.02964543e-07, 8.92684929e-08,
       7.74498636e-08, 6.72426387e-08, 5.84198804e-08, 5.07877608e-08,
       4.41805437e-08, 3.84563579e-08, 3.34936329e-08, 2.91880875e-08,
       2.54501834e-08, 2.22029675e-08, 1.93802423e-08, 1.69250119e-08,
       1.47881608e-08, 1.29273291e-08, 1.13059539e-08, 9.89245087e-09,
       8.65951625e-09, 7.58352899e-09, 6.64403955e-09, 5.82333185e-09,
       5.10604752e-09, 4.47886347e-09, 3.93021485e-09, 3.45005679e-09,
       3.02965943e-09, 2.66143133e-09, 2.33876724e-09, 2.05591687e-09,
       1.80787148e-09, 1.59026598e-09, 1.39929430e-09, 1.23163610e-09,
       1.08439342e-09, 9.55035734e-10, 8.41352348e-10, 7.41411100e-10,
       6.53522532e-10, 5.76208771e-10, 5.08176483e-10, 4.48293372e-10,
       3.95567731e-10] )
        moment1st = 1.4257689408749183
        moment2nd = 3.607599556312157

    return pk_list, moment1st, moment2nd
    

def get_empirical_1st_moment(pk_list: np.ndarray) -> float:
    return np.dot(pk_list, np.arange(pk_list.shape[0]))

        

    